webpackJsonp([0],{

/***/ 1031:
/***/ (function(module, exports) {

module.exports = "WKAKAKAKAK POST2\n\n```\nasdas\nasda\nsdasd\nasdasd\nasdasdas\nreturn 0;\n```\n\nCommonMark is a rationalized version of Markdown syntax,\nwith a [spec][the spec] and BSD3-licensed reference\nimplementations in C and JavaScript.\n\n[Try it now!](http://spec.commonmark.org/dingus.html)\n\nThe implementations\n-------------------\n\nThe C implementation provides both a shared library (`libcmark`) and a\nstandalone program `cmark` that converts CommonMark to HTML.  It is\nwritten in standard C99 and has no library dependencies.  The parser is\nvery fast (see [benchmarks](benchmarks.md)).\n\nIt is easy to use `libcmark` in python, lua, ruby, and other dynamic\nlanguages: see the `wrappers/` subdirectory for some simple examples.\n\nThe JavaScript implementation provides both an NPM package and a\nsingle JavaScript file, with no dependencies, that can be linked into\nan HTML page. For further information, see the\n[README in the js directory](js/README.md).\n\n**A note on security:**\nNeither implementation attempts to sanitize link attributes or\nraw HTML.  If you use these libraries in applications that accept\nuntrusted user input, you must run the output through an HTML\nsanitizer to protect against\n[XSS attacks](http://en.wikipedia.org/wiki/Cross-site_scripting).\n\nInstalling (C)\n--------------\n\nBuilding the C program (`cmark`) and shared library (`libcmark`)\nrequires [cmake].  If you modify `scanners.re`, then you will also\nneed [re2c], which is used to generate `scanners.c` from\n`scanners.re`.  We have included a pre-generated `scanners.c` in\nthe repository to reduce build dependencies.\n\nIf you have GNU make, you can simply `make`, `make test`, and `make\ninstall`.  This calls [cmake] to create a `Makefile` in the `build`\ndirectory, then uses that `Makefile` to create the executable and\nlibrary.  The binaries can be found in `build/src`.\n\nFor a more portable method, you can use [cmake] manually. [cmake] knows\nhow to create build environments for many build systems.  For example,\non FreeBSD:\n\n    mkdir build\n    cd build\n    cmake ..  # optionally: -DCMAKE_INSTALL_PREFIX=path\n    make      # executable will be created as build/src/cmark\n    make test\n    make install\n\nOr, to create Xcode project files on OSX:\n\n    mkdir build\n    cd build\n    cmake -G Xcode ..\n    make\n    make test\n    make install\n\nThe GNU Makefile also provides a few other targets for developers.\nTo run a benchmark:\n\n    make bench\n\nTo run a \"fuzz test\" against ten long randomly generated inputs:\n\n    make fuzztest\n\nTo run a test for memory leaks using `valgrind`:\n\n    make leakcheck\n\nTo reformat source code using `astyle`:\n\n    make astyle\n\nTo make a release tarball and zip archive:\n\n    make archive\n\n\nCompiling for Windows\n---------------------\n\nTo compile with MSVC and NMAKE:\n\n    nmake\n\nYou can cross-compile a Windows binary and dll on linux if you have the\n`mingw32` compiler:\n\n    make mingw\n\nThe binaries will be in `build-mingw/windows/bin`.\n\nInstalling (JavaScript)\n-----------------------\n\nThe JavaScript library can be installed through `npm`:\n\n    npm install commonmark\n\nThis includes a command-line converter called `commonmark`.\n\nIf you want to use it in a client application, you can fetch\na pre-built copy of `commonmark.js` from\n<http://spec.commonmark.org/js/commonmark.js>.\n\nFor further information, see the\n[README in the js directory](js/README.md).\n\nThe spec\n--------\n\n[The spec] contains over 500 embedded examples which serve as conformance\ntests. To run the tests using an executable `$PROG`:\n\n    python3 test/spec_tests.py --program $PROG\n\nIf you want to extract the raw test data from the spec without\nactually running the tests, you can do:\n\n    python3 test/spec_tests.py --dump-tests\n\nand you'll get all the tests in JSON format.\n\n[The spec]:  http://spec.commonmark.org/0.13/\n\nThe source of [the spec] is `spec.txt`.  This is basically a Markdown\nfile, with code examples written in a shorthand form:\n\n    .\n    Markdown source\n    .\n    expected HTML output\n    .\n\nTo build an HTML version of the spec, do `make spec.html`.  To build a\nPDF version, do `make spec.pdf`.  (Creating a PDF requires [pandoc]\nand a LaTeX installation.  Creating the HTML version requires only\n`libcmark` and `python3`.)\n\nThe spec is written from the point of view of the human writer, not\nthe computer reader.  It is not an algorithm---an English translation of\na computer program---but a declarative description of what counts as a block\nquote, a code block, and each of the other structural elements that can\nmake up a Markdown document.\n\nBecause John Gruber's [canonical syntax\ndescription](http://daringfireball.net/projects/markdown/syntax) leaves\nmany aspects of the syntax undetermined, writing a precise spec requires\nmaking a large number of decisions, many of them somewhat arbitrary.\nIn making them, we have appealed to existing conventions and\nconsiderations of simplicity, readability, expressive power, and\nconsistency.  We have tried to ensure that \"normal\" documents in the many\nincompatible existing implementations of Markdown will render, as far as\npossible, as their authors intended.  And we have tried to make the rules\nfor different elements work together harmoniously.  In places where\ndifferent decisions could have been made (for example, the rules\ngoverning list indentation), we have explained the rationale for\nmy choices.  In a few cases, we have departed slightly from the canonical\nsyntax description, in ways that we think further the goals of Markdown\nas stated in that description.\n\nFor the most part, we have limited ourselves to the basic elements\ndescribed in Gruber's canonical syntax description, eschewing extensions\nlike footnotes and definition lists.  It is important to get the core\nright before considering such things. However, we have included a visible\nsyntax for line breaks and fenced code blocks.\n\nDifferences from original Markdown\n----------------------------------\n\nThere are only a few places where this spec says things that contradict\nthe canonical syntax description:\n\n-   It allows all punctuation symbols to be backslash-escaped,\n    not just the symbols with special meanings in Markdown. We found\n    that it was just too hard to remember which symbols could be\n    escaped.\n\n-   It introduces an alternative syntax for hard line\n    breaks, a backslash at the end of the line, supplementing the\n    two-spaces-at-the-end-of-line rule. This is motivated by persistent\n    complaints about the “invisible” nature of the two-space rule.\n\n-   Link syntax has been made a bit more predictable (in a\n    backwards-compatible way). For example, `Markdown.pl` allows single\n    quotes around a title in inline links, but not in reference links.\n    This kind of difference is really hard for users to remember, so the\n    spec allows single quotes in both contexts.\n\n-   The rule for HTML blocks differs, though in most real cases it\n    shouldn't make a difference. (See the section on HTML Blocks\n    for details.) The spec's proposal makes it easy to include Markdown\n    inside HTML block-level tags, if you want to, but also allows you to\n    exclude this. It is also makes parsing much easier, avoiding\n    expensive backtracking.\n\n-   It does not collapse adjacent bird-track blocks into a single\n    blockquote:\n\n        > this is two\n\n        > blockquotes\n\n        > this is a single\n        >\n        > blockquote with two paragraphs\n\n-   Rules for content in lists differ in a few respects, though (as with\n    HTML blocks), most lists in existing documents should render as\n    intended. There is some discussion of the choice points and\n    differences in the subsection of List Items entitled Motivation.\n    We think that the spec's proposal does better than any existing\n    implementation in rendering lists the way a human writer or reader\n    would intuitively understand them. (We could give numerous examples\n    of perfectly natural looking lists that nearly every existing\n    implementation flubs up.)\n\n-   The spec stipulates that two blank lines break out of all list\n    contexts.  This is an attempt to deal with issues that often come up\n    when someone wants to have two adjacent lists, or a list followed by\n    an indented code block.\n\n-   Changing bullet characters, or changing from bullets to numbers or\n    vice versa, starts a new list. We think that is almost always going\n    to be the writer's intent.\n\n-   The number that begins an ordered list item may be followed by\n    either `.` or `)`. Changing the delimiter style starts a new\n    list.\n\n-   The start number of an ordered list is significant.\n\n-   Fenced code blocks are supported, delimited by either\n    backticks (```` ``` ```` or tildes (` ~~~ `).\n\nContributing\n------------\n\nThere is a [forum for discussing\nCommonMark](http://talk.commonmark.org); you should use it instead of\ngithub issues for questions and possibly open-ended discussions.\nUse the [github issue tracker](http://github.com/jgm/CommonMark/issues)\nonly for simple, clear, actionable issues.\n\nAuthors\n-------\n\nThe spec was written by John MacFarlane, drawing on\n\n- his experience writing and maintaining Markdown implementations in several\n  languages, including the first Markdown parser not based on regular\n  expression substitutions ([pandoc](http://github.com/jgm/pandoc)) and\n  the first markdown parsers based on PEG grammars\n  ([peg-markdown](http://github.com/jgm/peg-markdown),\n  [lunamark](http://github.com/jgm/lunamark))\n- a detailed examination of the differences between existing Markdown\n  implementations using [BabelMark 2](http://johnmacfarlane.net/babelmark2/),\n  and\n- extensive discussions with David Greenspan, Jeff Atwood, Vicent\n  Marti, Neil Williams, and Benjamin Dumke-von der Ehe.\n\nJohn MacFarlane was also responsible for the original versions of the\nC and JavaScript implementations.  The block parsing algorithm was\nworked out together with David Greenspan.  Vicent Marti\noptimized the C implementation for performance, increasing its speed\ntenfold.  Kārlis Gaņģis helped work out a better parsing algorithm\nfor links and emphasis, eliminating several worst-case performance\nissues.  Nick Wellnhofer contributed many improvements, including\nmost of the C library's API and its test harness.  Vitaly Puzrin\nhas offered much good advice about the JavaScript implementation.\n\n[cmake]: http://www.cmake.org/download/\n[pandoc]: http://johnmacfarlane.net/pandoc/\n[re2c]: http://re2c.org"

/***/ })

});